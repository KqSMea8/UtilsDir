//------------------------------------------------------------------------------
/**
	Класс CStationaryMode предназначен для использования в компонентах СОУ
с целью определения стационарности режима работы нефтепровода для одного ДД.
Условие стационарности: если измеренные значения не выходят из коридора, заданной
ширины (по умолчанию +-0,0015 МПа), то режим считается стационарным. Коридор
при этом может изменять своё положение. Исходные данные - это среднее за 1 сек
значение давления, измеряемое ДД.
	В классе есть четыре значения полуширины: минимально возможная (ограничение
из соображений турбулентности из РД, +-0,0015 МПа), наблюдаемая (следствие данной
шумовой обстановки, определяется во время работы компонента), задаваемая
оператором в конфигурационном xmp-файле и, наконец, действующая, т.е.
максимальная из трёх перечисленных.
	Используются функции библиотеки IPP 7.0.

	Инициализация экземпляра класса.
	Если требуется работа с параметрами по умолчанию, то достаточно конструктора
по умолчанию. Иначе используем конструктор с параметрами или вызываем функции
задания параметров класса (размер массивов и величина полуширины). Текущий режим
вначале считается не определённым.
		Работа.
	Для добавления нового значения в массив исходных данных используется
функция Add. В её коде определяется новый режим работы (вычитывается функцией
GetModeCur) и флаг его изменения (вычитывается функцией IsChangeMode).
*/
//------------------------------------------------------------------------------
#pragma once
//------------------------------------------------------------------------------
#include "afx.h"
#include "float.h"
#include <LDS\lds.h>
#include <Intel\ipp\ipps.h>
#include <Metrology\SpaceProbability.h>
//------------------------------------------------------------------------------
#define Min_Value_Half_Width	0.0015f	// +-1.5 кПа - турбулентная составляющая
//------------------------------------------------------------------------------
class CStationaryMode
{
private:
	/// флаг заполнения массива исходных данных
	bool m_bFull;
	bool m_bThresholdEnabled;
	/// флаг изменения режима стационарности
	bool m_bChangeMode;
	/// размер массива исходных данных
	int m_size;
	// Размер данных, по которым рассчитывается одна точка
	UINT m_sizePage;
	/// текущий индекс записи в массив исходных данных
	int m_index;
	/// индекс текущего минимального значения
	int m_indexMin;
	/// индекс текущего максимального значения
	int m_indexMax;				// = 2 * m_valNotStationary
	/// текущее минимальное значение
	float m_valMin;
	/// текущее максимальное значение
	float m_valMax;

	float m_valNotStat_Min;			// мин. возможное значение 
	float m_valNotStat_Prob;		// вероятностное значение
	float m_valNotStat_User;		// значение, задаваемое оператором
	/// значение порога нестационарности
	float m_WidthHalf;				// максимальное из трёх
	float m_Width;	
	/// тип текущего режима (неопределён, стационарный да/нет)
	Lds_type_Stationary m_ModeCur;
	/// указатель на массив исходных данных
	float *m_pData;

	void CalcCurStationary();
	
protected:

public:
	/// Конструктор класса
	CStationaryMode();
	/// Конструктор класса с параметрами
	CStationaryMode(const int size, const float valHalfWidth);
	/// Конструктор копирования
	CStationaryMode(const CStationaryMode &val);
	/// Деструктор класса
	~CStationaryMode();
	void operator = (const CStationaryMode &val);

	/// Функция, возвращающая размер массива исходных данных
	int GetSize() { return m_size; }
	/// Задание пользовательских значений размеров массивов и
	/// вызов функции ReStart
	bool SetSize(const int size);

	bool GetThresholdsEnabled() { return m_bThresholdEnabled; }

	UINT GetSizePage() { return m_sizePage; }
	void SetSizePage(UINT newVal);

	float* GetDataPointer() { return m_pData; }
	float GetProbabilityHalfWidth() { return m_valNotStat_Prob; }

	/// Функция, возвращающая флаг изменения режима работы
	bool IsChangeMode() { return m_bChangeMode; }
	/// Функция, возвращающая флаг заполнения массива исходных данных
	bool IsFull() { return m_bFull; }
	/// Функция, возвращающая текущий режим работы
	Lds_type_Stationary GetMode() { return m_ModeCur; }
	/// Функция, возвращающая значение ширины
	float GetUserHalfWidth() { return m_valNotStat_User; }
	/// Функция задания пользовательского размера ширины стационарности
	void SetUserHalfWidth(const float val) {
		if (0.f < val) m_valNotStat_User = val;	}

	/// Функция добавления нового значения давления. Значение добавляется в
	/// массив исходных данных. Если этот массив заполнен, рассчитывается
	/// новое значение среднего, которое добавляется в массив средних.
	/// Если в массиве средних 3 и более значений, то определяется новый режим
	/// и флаг его изменения.
	/// Возвращаемое значение true при условии, что массивы уже существуют
	bool Add(const float val, Lds_type_Stationary *pTypeStationary = NULL,
		bool *pbChangeMode = NULL);

	bool CalcThresholds();
	/// Копирование данных
	bool CopyDataToSpace(CSpace<float> &sp);

	/// Функция используется для обнуления массивов. Размеры не изменяются.
	/// Текущий режим устанавливается не определённым.
	void Clear();
};
//------------------------------------------------------------------------------