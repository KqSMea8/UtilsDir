//------------------------------------------------------------------------------
/* Файл CalcFFT_64.h


Класс CCalcFFT_64f ПРЕДНАЗНАЧЕН для выполнения расчетов прямого и обратного
БПФ для данных типа double. Класс является насоедником базового класса CustomCalcFFT".

СОСТАВ класса:
- тройка ООП (деструктор, конструктор копирования и оператор присваивания);
- две функции для выполнения прямого БПФ;
- три функции для выполнения обратного БПФ.

Наследуюемын от базового класса функции:
- четыре свойста с функциями Get и Set;
- две функции получения размеров.

Функции для выполнения ПРЯМОГО БПФ
1. CalcFwd_RToC - реальные исходные данные преобразуются в комплексный спектр.
Вначале выполняется прямое БПФ, результат которого выдаётся в формате Perm
(формат библиотеки IPP 7.0). Затем результат преобразуется в комплексный спектр.
2. CalcFwd_C0ToC - реальные исходные данные преобразуются в комплексный спектр.
Вначале создаётся комплексный входной сигнал, у которого реальная часть -
исходные данные функции, а мнимая часть равна 0. Затем выполняется прямое БПФ,
результат которого комплексный спектр.

Функции для выполнения ОБРАТНОГО БПФ
1. CalcInv_CToC - преобразование комплексного спектра в комплексный сигнал.
2. CalcInv_CToR - преобразование комплексного спектра в реальный сигнал. Вначале
комплексный спектр преобразуется в данные формата Perm. Затем выполнется обратное
БПФ, результатом которого являются реальные данные.
3. CalcInv_CToC_I - преобразование комплексного спектра в комплексный сигнал.
При этом для клмплексного сигнала используется массив с исходным спектром.
*/
//------------------------------------------------------------------------------
#pragma once
#include "CustomCalcFFT.h"
//------------------------------------------------------------------------------
class CCalcFFT_64f : public CCustomCalcFFT
{
private:
	// нормировочный множитель, зависящий от временного окна и типа входных данных
	Ipp64f m_factorFFT;

	// Структуры для расчета FFT
	IppsFFTSpec_R_64f * m_pStruct_R;
	IppsFFTSpec_C_64fc * m_pStruct_C;
	SmartArray<Ipp8u> m_saStruct_R;
	SmartArray<Ipp8u> m_saStruct_C;

	SmartArray<double> m_saWindow;		// временное окно

	// Массивы для данных, size = m_sizeFFT
	SmartArray<double> m_saFwd_SrcRe;
	SmartArray<double> m_saFwd_SrcIm;
	SmartArray<Ipp64fc> m_saFwd_SrcC;
	
	// Массив с данными в формате Perm, size = m_sizeFFT
	SmartArray<double> m_saDataPerm;

	// Приватные функции ------------------------------------

	// Удаление служебных структур
	virtual void DeleteStructure_All();
	virtual void DeleteStructure_FFT();
	virtual void ReSize_saWindow(DWORD size);

	long Create_Structure_R();
	long Create_Structure_C();

	void Calc_FactorFFT();
	long Create_ReDataForFwd(double * pData, const int sizeData, int * psize);
	bool SetTimeWindow(const int sizeData);
	void CorrectZeroItem(Ipp64fc * pData);
	bool ConvertToPerm(Ipp64fc * pData);
	void CorrectConstComponent(const double re0, double * pData, const int size);
	void CorrectConstComponent(const double re0, Ipp64fc * pData, const int size);

protected:

public:
	CCalcFFT_64f(const int order = 7);
	~CCalcFFT_64f();
	CCalcFFT_64f(const CCalcFFT_64f & val);
	CCalcFFT_64f & operator = (const CCalcFFT_64f & val);

	// Прямое FFT.
	// Преобразование реального сигнала в комплексный спектр.
	// - pSrc - реальные входные данные с размером от 1 до m_sizeFFT;
	// - pDst - комплексные выходные данные с размером m_sizeFFT;
	// - sizeSrc - размер входного массива.
	// Если sizeSrc = 0, то размер входного массива = m_sizeFFT.
	// Если sizeSrc меньше m_sizeFFT, то перед расчетами во входной массив
	// добавляются нули. Если больше - то лишние данные игнорируются.
	// Возвращается код ошибки ErrorCodes.
	long CalcFwd_RToC(double * pSrc, Ipp64fc * pDst, const int sizeSrc = 0);

	// Прямое FFT. Преобразование комплексного сигнала с нулевой мнимой частью
	// в комплексный спектр.
	// - pSrc - реальные входные данные Re с размером от 1 до m_sizeFFT;
	// - pDst - комплексные выходные данные с размером m_sizeFFT;
	// - sizeSrc - размер входного массива.
	// Если sizeSrc = 0, то размер входного массива = m_sizeFFT.
	// Если sizeSrc меньше m_sizeFFT, то перед расчетами во входной массив
	// добавляются нули. Если больше - то лишние данные игнорируются.
	// Возвращается код ошибки ErrorCodes.
	long CalcFwd_C0ToC(double * pSrc, Ipp64fc * pDst, const int sizeSrc = 0);

	// Прямое FFT. Преобразование комплексного сигнала в комплексный спектр.
	// - pSrc - комплексные входные данные размером m_sizeFFT;
	// - pDst - комплексные выходные данные с размером m_sizeFFT.
	// При выполнении этой функции игнорируются свойства центрирования
	// исходного сигнала и применение временного окна!
	// Возвращается код ошибки ErrorCodes.
	long CalcFwd_CToC(Ipp64fc * pSrc, Ipp64fc * pDst);

	// Прямое FFT. Преобразование комплексного сигнала в комплексный спектр.
	// - pSrcDst - комплексные входные и выходные данные размером m_sizeFFT.
	// При выполнении этой функции игнорируются свойства центрирования
	// исходного сигнала и применение временного окна!
	// Возвращается код ошибки ErrorCodes.
	long CalcFwd_CToC_I(Ipp64fc * pSrcDst);

	// Расчёт обратного FFT. Преобразование комплексного спектра в
	// реальный сигнал.
	// - pSrc - комплексные входные данные размером m_sizeFFT;
	// - pDst - реальные выходные данные размером m_sizeFFT.
	// Возвращается код ошибки ErrorCodes.
	long CalcInv_CToR(Ipp64fc * pSrc, double * pDst);

	// Расчёт обратного FFT. Преобразование комплексного спектра в
	// комплексный сигнал.
	// - pSrc - комплексные входные данные размером m_sizeFFT;
	// - pDst - комплексные выходные данные размером m_sizeFFT.
	// Возвращается код ошибки ErrorCodes.
	long CalcInv_CToC(Ipp64fc * pSrc, Ipp64fc * pDst);

	// Расчёт обратного FFT. Преобразование комплексного спектра в
	// комплексный сигнал.
	// - pSrcDst - комплексные входные и выходные данные размером m_sizeFFT;
	// Возвращается код ошибки ErrorCodes.
	long CalcInv_CToC_I(Ipp64fc * pSrcDst);
};
//------------------------------------------------------------------------------