//------------------------------------------------------------------------------
/* Файл CustomCalcFFT.h

	Базовый класс СCustomCalcFFT классов, предназначенных ддя выполнения
расчетов прямого иобратного БПФ (для float и double), выполняемых с помощью
функций библиотеки IPP 7.0.

	ЦЕЛЬЮ разработки этих классов является создание кода, в котором функции
библиотеки вызываются в правильных местах, с правильными параметрами и результаты
выполнения этих функций хранятся в правильных членах класса.

	ЗАДАЧИ, решаемые при разработке классов:
- оптимизация использования служебной памяти, необходимой при расчетах БПФ;
- решение проблемы нормировки результатов расчетов;
- решение проблемы нулевой полосы спектра (постоянной составляющей сигнала);
- реализация положительных побочных свойств, таких как:
	* центровка исходных данных;
	* использование временных окон, накладываемых на исходные данные;
	* работа с исходными данными в виде аналитического сигнала (для float).

	СОСТАВ класса:
	- тройка ООП (деструктор, конструктор копирования и оператор присваивания);
	- четыре свойста с функциями Get и Set;
	- две функции получения размеров.

	Базовый класс содержит функции работы со свойствами классов и функции
получения размеров.
	СВОЙСТВА класса
1. int OrderFFT - порядок БПФ, определяет размер данных. Допустимый диапазон
значений от 7 до 20 включительно. По умолчанию 7.
2. bool CenteringSrcData - центровка исходных данных (удаление постоянной
составляющей исходного сигнала) перед выполнением прямого БПФ. По умолчанию
false.
3. Перечисление TypeNormalization - тип нормировки данных при выполнении БПФ,
соответствует типам библиотеки IPP 7.0 (без нормировки, нормировка типа 1/N и
нормировка типа 1/sqrt(N)). По умолчанию нормировка типа 1/N.
4. Перечисление TypeWindowForFFT - тип используемого временного окна, см. ниже.
По умолчанию без окна.

	Функции получения РАЗМЕРОВ
1. GetSize - возвращает значение 2 ^ OrderFFT.
2. GetHalfSize - возвращает значение (2 ^ OrderFFT) / 2.

	Некоторые РЕЗУЛЬТАТЫ и замечания к клаасам наследникам.

1. Чтобы избежать создания и удаление служебной памяти внутри используемых функций
библиотеки каждый раз при выполнении БПФ, в классе один раз создаётся служебный
буфер, размер которого определяется с помощью соответствующих функций библиотеки.

2. В случае выбора нормировки типа 1/N при входном гармоническом сигнале величина,
равная корню квадратному из суммы квадратов re и im спектра в полосе данной
гармоники, равна амплитуде исходного сигнала.

3. Если создать реальный гармонический сигнал с частотой, в 8 раз (точнее в 2^m,
где m - натуральное число соответствующей величины) меньше частоты дискретизации,
то комплексные спектры, полученные с помощью всех трёх функций прямого БПФ будут
одинаковыми независимо от значений амплитуды, постоянной составляющей и начальной
фазы гармонического сигнала (с точностью не хуже 10^-6).

4. В случае выбора нормировки типа 1/N или 1/sqrt(N) при входном комплексном
спектре по п. 3 результат функции CalcInv_CToR (как и реальная часть результата
функции CalcInv_CToC) будет совпадать с исходным гармоническим сигналом (с
точностью не хуже 10^-6) не зависимо от значения амплитуды, постоянной
составляющей и начальной фазы исходного сигнала. При этом не следует использовать
весовое временное окно и выборка гармонического сигнала должна точно содержать
целое число периодов исходного сигнала (известное требование возможности
использования БПФ). Это является следствием правильного решения проблемы
нулевой полосы спектра.

5. Несмотря на то, что сигнал с постоянной составляющей правильно
преобразовывается в спектр при прямом БПФ, в случаях, когда постоянная
составляющая не является информативным параметром, её лучше удалять с помощью
установки свойства CenteringSrcData в true, т.к. это влияет на динамический
диапазон получаемого спектра (при больших значениях постоянной составляющей).
*/
//------------------------------------------------------------------------------
#pragma once
#include <mathZet.h>
#include <ZetErrorCodes.h>	// коды ошибок
#include <Buffer\SmartArray.h>
#include <Intel\ipp\ipps.h>
#include <Algorithms\FunctionsUsingIPP.h>
#include "TemplateWindow.h"
//------------------------------------------------------------------------------
#define OrderFFT_Min	7
#define OrderFFT_Max	20
//------------------------------------------------------------------------------
// Перечень типов нормировки результатов преобразования
enum TypeNormalization : BYTE
{
	norm_no,				// без нормировки
	norm_N,					// нормировка (1 / N) для Fwd
	norm_Sqrt_N,			// нормировка (1 / sqrt(N)) для Fwd и Inv
	norm_N_inv,				// нормировка (1 / N для Inv

	norm_size
};
//------------------------------------------------------------------------------
// Перечень типов временных окон.
// Новые типы добавлять ТОЛЬКО в конец, перед win_size!
enum TypeWindow : BYTE
{
	win_no,					// без окна
	win_Bartlett,			// окно Бартлета
	win_Blackman,			// стандартное окно Блекмэна
	win_Hamming,			// окно Хэннинга
	win_Hann,				// окно Ханна
	win_Kaiser,				// стандартное окно Кайзера

	win_Hanning,			// окно Хэннинга
	win_RifeVincent_4,		// окно Рифа-Винсента (4)
	win_BlackmanHarris_3,	// окно Блэкмана-Харриса (3)
	win_BlackmanHarris_4,	// окно Блэкмана-Харриса (4)
	win_Nuttall,			// окно Наталла
	win_BlackmanNuttall,	// окно Блэкмана-Наталла
	win_Flattop,			// окно с плоской вершиной

	win_size
};
//------------------------------------------------------------------------------
class CCustomCalcFFT
{
private:

protected:

	bool m_bCenteringSrcData;		// центровка исходных данных Fwd 
	TypeWindow m_typeWin;			// тип временного окна при Fwd FFT
	TypeNormalization m_typeNorm;	// тип нормировки результатов FFT
	bool b4;
	int m_factorTypeSrc;			// нормировка по типу входных данных

	int m_nOrderFFT;				// порядок FFT
	int m_sizeFFT;					// = 2 ^ order

	int m_sizeFFT_2;				// = m_sizeFFT / 2
	int m_sizeHilbert;				// размер данных в структуре Hilbert

	double m_sqrt_N;				// = 1 / sqrt(m_sizeFFT)
	double m_factorWindow;			// амплитудный коэфф. временного окна
	double m_factorEnergyWindow;	// энергетический коэфф. временного окна

	// Служебная память
	SmartArray<Ipp8u> m_saBuffer_8u;

	// Приватные функции ------------------------------------
	// Получение флага для прямого преобразования
	int GetFlagForFwd();

	virtual void DeleteStructure_FFT() {}
	virtual void DeleteStructure_All() {}

	virtual void ReSize_saWindow(DWORD size) {}

public:
	CCustomCalcFFT(const int order = 7);
	~CCustomCalcFFT();
	CCustomCalcFFT(const CCustomCalcFFT & val);
	CCustomCalcFFT & operator = (const CCustomCalcFFT & val);

	// Получение флага центрирования исходного сигнала при Fwd.
	// По умолчанию - false.
	bool GetCenteringSrcData();
	// Задание флага центрирования исходного сигнала при Fwd
	void SetCenteringSrcData(const bool val);

	// Получение типа нормировки результатов. По умолчанию - 1/N.
	TypeNormalization GetTypeNormalization();
	// Задание типа нормировки результатов
	void SetTypeNormalization(const TypeNormalization type);

	// Получение типа временного окна. По умолчанию - без окна.
	TypeWindow GetTypeWindowForFFT();
	// Задание типа временного окна
	void SetTypeWindowForFFT(const TypeWindow type);

	// Получение порядка FFT. По умолчанию - 7.
	int GetOrderFFT();
	// Задание порядка FFT
	void SetOrderFFT(const int order);

	// Получение размера данных = 2 ^ orderFFT
	virtual int GetSize();

	// Получение половины размера данных = (2 ^ orderFFT) / 2
	virtual int GetHalfSize();

	// Получение амплитудного фактора временного окна
	double GetTimeWindowAmplFactor() { return m_factorWindow; }
	// Получение энергерического  фактора временного окна
	double GetTimeWindowEnergyFactor() { return m_factorEnergyWindow; }
};
//------------------------------------------------------------------------------