//------------------------------------------------------------------------------
/*	Данная версия продукта - тестировочная.
Её цель - на API-функциях протестировать работоспособность класса
*/
//------------------------------------------------------------------------------
#pragma once
//------------------------------------------------------------------------------
// Перечень идентификаторов потоков логера
enum LoggerThreadID
{
	tw_Struct,			// Thread Write Struct
	tw_Register,		// Thread Write Register
	tr_Struct,			// Thread Read Struct
	tr_Register,		// Thread Read Register
};
//------------------------------------------------------------------------------
#include "CustomLogger.h"
//------------------------------------------------------------------------------
class ZETLOGGER_API CLogger : public CCustomLogger
{
private:
public:
	// Конструктор класса. Параметры:
	// loggerName - имя создаваемого экземпляра класса, используется при выводе в OutputDebugString;
	// fileName - полное имя файла (можно без расширение файла ".sqlite");
	// password - пароль для достура к этому файлу.
	CLogger(
		const std::string loggerName = "",
		const std::string fileName = "",
		const std::string password = "");

	virtual ~CLogger();

	// Получение имени файла БД
	long GetFileName(std::string & fileName);

	// Задание имени файла БД для чтения из него структур (с подключением к нему)
	long SetFileNameForRead(std::string & fileName);

	// Задание имени файла БД для записи в него структур (с подключением к нему)
	long SetFileNameForWrite(std::string & fileName);

	// Запись в БД бинарных файлов структур, предназначенных
	// для записи данным логгером.
	// Возвращаемое значение:
	// отрицательное значение - код ошибки;
	// 0 - файлы записаны в контейнер и запущен рабочий поток,
	//     в котором файлы из этого контейнера будут записаны в БД
	long Register(const std::vector<ZetHeader*> & descriptors);

	// Запись в БД одной структуры.
	// Возвращаемое значение:
	// отрицательное значение - код ошибки;
	// 0 - структура скопирована в контейнер, по заполнению которого
	//		все структуры из него в рабочем потоке будут записаны в БД.
	long Write(const ZetHeader & rHeader);

	// Чтение из файла БД структур, удовлетворяющим условиям фильтров.
	// Фильтр - это строка с числами, разделёнными ";". В конце тоже";".
	// Числа можно задавать в шестнадцатеричном виде (0х0hhhh или 0X0HHHH).
	// Формат времён "%Y-%m-%d %H:%M:%S"
	// Возвращаемое значение:
	// отрицательное значение - код ошибки;
	// 0 - запущен рабочий поток чтения, результат позже можно получить с
	//     помощью функции GetReadResult().
	long Read(
		ReadDataType * pData,
		const std::string timeFrom = "",
		const std::string timeTo = "",
		const std::string filterTypeStructure = "",
		const std::string filterProgramID = "",
		const std::string filterProgramNumber = "",
		const std::string filterModuleID = "",
		const std::string filterModuleNumber = "");

	// Получение результата работы рабочего потока чтения.
	// Возвращаемое значение:
	// отрицательное значение - код ошибки;
	//-23 - поток не запущен;
	// 0 - поток завершил свою работу;
	// 5 - поток ожидает доступа к файлу;
	// 7 - успешное завершение работы;
	// 8 - завершение работы с ошибкой.
	StatusThread GetReadResult(LoggerThreadID id = tr_Struct);

	// Чтение из БД бинарных файлов структур.
	// Возвращаемое значение:
	// отрицательное значение - код ошибки;
	// 0 - запущен рабочий поток чтения, результат позже можно получить с
	//     помощью функции GetReadResult().
	long ReadRegister(ReadDataRegisterType & descriptors);
};
//------------------------------------------------------------------------------